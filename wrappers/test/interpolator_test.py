#!/usr/bin/env python

import numpy as np
import unittest

import sys
sys.path.append('../mod')

import interpolator
import matrix

class Interpolator(unittest.TestCase):

    def testLinearNode(self):
        # Test if linear interpolator gives node value when interpolating at node
        data = matrix.Matrix(10, 2)
        for i in range(10):
            data.SetVal(i, 0, i)
            data.SetVal(i, 1, np.sin(i))
        interp = interpolator.LinInterp()
        icol = 0
        cols = 2
        vecout = np.zeros((cols))
        for i in range(10):
            flag = interp.Interp(data, icol, data.GetVal(i, 0), vecout)
            self.assertEqual(flag, 0)
            self.assertAlmostEqual(vecout[1], data.GetVal(i, 1))

    def testCubicNode(self):
        # Test if cubic interpolator gives node value when interpolating at node
        data = matrix.Matrix(10, 2)
        for i in range(10):
            data.SetVal(i, 0, i)
            data.SetVal(i, 1, np.cos(i))
        interp = interpolator.CubicInterp()
        icol = 0
        cols = 2
        vecout = np.zeros((cols))
        for i in range(10):
            flag = interp.Interp(data, icol, data.GetVal(i, 0), vecout)
            self.assertEqual(flag, 0)
            self.assertAlmostEqual(vecout[1], data.GetVal(i, 1))

    def testHermiteNode(self):
        # Test if cubic Hermite interpolator gives node value when interpolating at node
        data = matrix.Matrix(10, 2)
        for i in range(10):
            data.SetVal(i, 0, i)
            data.SetVal(i, 1, np.tan(i))
        interp = interpolator.HermiteInterp()
        icol = 0
        cols = 2
        vecout = np.zeros((cols))
        for i in range(10):
            flag = interp.Interp(data, icol, data.GetVal(i, 0), vecout)
            self.assertEqual(flag, 0)
            self.assertAlmostEqual(vecout[1], data.GetVal(i, 1))

    def testLinearLinfunc(self):
        # Test if linear interpolator is exact for data generated by linear function
        def f(x):
            return 3.0*x + 5.0
        data = matrix.Matrix(10, 2)
        for i in range(10):
            data.SetVal(i, 0, i)
            data.SetVal(i, 1, f(i))
        interp = interpolator.LinInterp()
        icol = 0
        cols = 2
        vecout = np.zeros((cols))
        for i in range(9):
            x = i + 0.5
            flag = interp.Interp(data, icol, x, vecout)
            self.assertEqual(flag, 0)
            self.assertAlmostEqual(vecout[1], f(x))

    def testCubicLinearfunc(self):
        # Test if cubic interpolator is exact for data generated by linear function
        def f(x):
            return 4.0*x - 1.1
        data = matrix.Matrix(10, 2)
        for i in range(10):
            data.SetVal(i, 0, i)
            data.SetVal(i, 1, f(i))
        interp = interpolator.CubicInterp()
        icol = 0
        cols = 2
        vecout = np.zeros((cols))
        for i in range(9):
            x = i + 0.2
            flag = interp.Interp(data, icol, x, vecout)
            self.assertEqual(flag, 0)
            self.assertAlmostEqual(vecout[1], f(x))

    def testHermiteLinearfunc(self):
        # Test if cubic Hermite interpolator is exact for data generated by linear function
        def f(x):
            return -3.0*x - 0.6
        data = matrix.Matrix(10, 2)
        for i in range(10):
            data.SetVal(i, 0, i)
            data.SetVal(i, 1, f(i))
        interp = interpolator.HermiteInterp()
        icol = 0
        cols = 2
        vecout = np.zeros((cols))
        for i in range(9):
            x = i + 0.75473
            flag = interp.Interp(data, icol, x, vecout)
            self.assertEqual(flag, 0)
            self.assertAlmostEqual(vecout[1], f(x))

    def testLinearExtrap(self):
        # Test if linear interpolator returns correct flag when attempting extrapolation
        data = matrix.Matrix(2, 2)
        for i in range(2):
            data.SetVal(i, 0, i)
            data.SetVal(i, 1, 2*i)
        interp = interpolator.LinInterp()
        icol = 0
        cols = 2
        vecout = np.zeros((cols))
        self.assertEqual(interp.Interp(data, icol, -1.0, vecout), 1) # x < xmin
        self.assertEqual(interp.Interp(data, icol, 2.0, vecout), 1)  # x > xmax

    def testCubicExtrap(self):
        # Test if cubic interpolator returns correct flag when attempting extrapolation
        data = matrix.Matrix(2, 2)
        for i in range(2):
            data.SetVal(i, 0, i)
            data.SetVal(i, 1, 3*i)
        interp = interpolator.CubicInterp()
        icol = 0
        cols = 2
        vecout = np.zeros((cols))
        self.assertEqual(interp.Interp(data, icol, -1.0, vecout), 1) # x < xmin
        self.assertEqual(interp.Interp(data, icol, 2.0, vecout), 1)  # x > xmax

    def testHermiteExtrap(self):
        # Test if cubic Hermite interpolator returns correct flag when attempting extrapolation
        data = matrix.Matrix(2, 2)
        for i in range(2):
            data.SetVal(i, 0, i)
            data.SetVal(i, 1, 5*i)
        interp = interpolator.HermiteInterp()
        icol = 0
        cols = 2
        vecout = np.zeros((cols))
        self.assertEqual(interp.Interp(data, icol, -1.0, vecout), 1) # x < xmin
        self.assertEqual(interp.Interp(data, icol, 2.0, vecout), 1)  # x > xmax

    def testCase(self):
        # Test if the interpolators return the correct answer for a specific case
        data = matrix.Matrix(4, 3)
        for i in range(4):
            data.SetVal(i, 0, i)
            data.SetVal(i, 1, i*i*i - 1)
            data.SetVal(i, 2, i*i + 1)
        interps = [interpolator.LinInterp(), interpolator.CubicInterp(), interpolator.HermiteInterp()]
        icol = 0
        cols = 3
        vecout = np.zeros((cols))
        x = 1.5
        yt = [[x, 3.5, 3.5], [x, 2.15, 3.2], [x, 2.375, 3.25]]
        for i in range(3):
            flag = interps[i].Interp(data, icol, x, vecout)
            self.assertEqual(flag, 0)
            np.testing.assert_array_almost_equal(vecout, yt[i])

if __name__ == '__main__':
    unittest.main()
